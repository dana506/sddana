#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>

union Reference
{
	unsigned char intRef;
	unsigned short extRef;
};

typedef union Reference RefInfo;

struct Student
{
	char* name;
	double income;
	RefInfo reference;
};

typedef struct Student StudentInfo;

struct HTable
{
	StudentInfo** items;
	int hSize;
};

typedef struct HTable HashTable;


//useful info memory management
StudentInfo* createStudentInfo(const char*, double, unsigned short);
void* deleteStudentInfo(StudentInfo*);
void displayStudents(StudentInfo**, int);
void displayStudent(StudentInfo*);
int linearProbing(HashTable*, char, int);
int fhash(char, int);
void putHashTable(HashTable*, StudentInfo*);
void resizeHT(HashTable*);

#define LINE_SIZE 128
#define HT_INITIAL_SIZE 3

void main()
{
	FILE* pFile = fopen("Data.txt", "r");
	HashTable hashTable = { .items = NULL, .hSize = 0 };

	if (pFile)
	{
		StudentInfo* agenda[10];
		memset(agenda, 0, sizeof(agenda));
		char* token; char delimiter[] = ",\n";
		double income; unsigned short ref;
		char lineBuffer[LINE_SIZE], name[LINE_SIZE];
		int index = 0;
		while (fgets(lineBuffer, sizeof(lineBuffer), pFile))
		{
			token = strtok(lineBuffer, delimiter);
			strcpy(name, token);
			token = strtok(NULL, delimiter);
			income = atof(token);
			token = strtok(NULL, delimiter);
			ref = atoi(token);
			StudentInfo* stud = createStudentInfo(name, income, ref);
			putHashTable(&hashTable, stud);
		}
		printf("\n----------------Hash Table Items--------------------\n");
		displayStudents(hashTable.items, hashTable.hSize);
		
		fclose(pFile);
	}
}


StudentInfo* createStudentInfo(const char* name, double income, unsigned short ref)
{
	StudentInfo* result = NULL;

	result = (StudentInfo*)malloc(sizeof(StudentInfo));
	result->name = (char*)malloc(strlen(name) + 1);
	strcpy(result->name, name);
	result->income = income;
	result->reference.extRef = ref;
	return result;

}

void* deleteStudentInfo(StudentInfo* stud)
{
	if (stud != NULL)
	{
		free(stud->name);
		free(stud);
	}
	return NULL;
}

void displayStudents(StudentInfo** agenda, int noEl)
{
	for (int i = 0; i < noEl; i++)
	{
		printf("Bucket %d:\n", i);
		displayStudent(agenda[i]);
	}
}

void displayStudent(StudentInfo* stud)
{
	if (stud)
	{
		printf("Name: %s, income: %f\n", stud->name, stud->income);
		if (stud->reference.extRef >> 15 == 1)
		{
			short uid = stud->reference.extRef >> 8 & 127;
			printf("University ref: %d\n", uid);
			printf("External ref: %d\n", stud->reference.extRef & 255);
		}
		else
		{
			printf("Internal ref: %d\n", stud->reference.intRef);
		}
	}
}


int linearProbing(HashTable* hTabel, char key, int index)
{
	while (hTabel->items[index] != NULL)
	{
		index++;
		if (hTabel->hSize == index)
		{
			printf("\n----------------Hash Table Items before Resize-------------------\n");
			displayStudents(hTabel->items, hTabel->hSize);
			resizeHT(hTabel);
			index = fhash(key, hTabel->hSize);
		}
	}
	return index;
}

int fhash(char key, int size)
{
	return key % size;
}


void putHashTable(HashTable* hTable, StudentInfo* stud)
{
	if (hTable->hSize == 0)
	{
		hTable->items = (StudentInfo**)malloc(sizeof(StudentInfo*) * HT_INITIAL_SIZE);
		hTable->hSize = HT_INITIAL_SIZE;
		memset(hTable->items, 0, sizeof(StudentInfo*) * HT_INITIAL_SIZE);
	}
	int index = fhash(stud->reference.intRef, hTable->hSize);
	if (hTable->items[index] != NULL)
	{
		char key = stud->reference.intRef;
		index = linearProbing(hTable, key, index);
	}
	hTable->items[index] = stud;
}

void resizeHT(HashTable* hTable)
{
	StudentInfo** aux = hTable->items;
	hTable->hSize *= 3;
	hTable->items = (StudentInfo**)malloc(sizeof(StudentInfo*) * hTable->hSize);
	memset(hTable->items, 0, sizeof(StudentInfo*) * hTable->hSize);
	for (int index = 0; index < hTable->hSize / 3; index++)
	{
		StudentInfo* stud = aux[index];
		if (stud != NULL)
		{
			putHashTable(hTable, stud);
		}
	}
}
